{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst WS_URL = 'ws://localhost:3003';\nconst RECONNECT_INTERVAL = 3000;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst PING_INTERVAL = 15000; // 15 seconds\nconst PONG_TIMEOUT = 5000; // 5 seconds\n\nexport function useWebSocket() {\n  _s();\n  const [logs, setLogs] = useState([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [lastUpdate, setLastUpdate] = useState(() => new Date());\n  const [opportunities, setOpportunities] = useState([]);\n  const wsRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const reconnectTimeout = useRef(undefined);\n  const pingInterval = useRef(undefined);\n  const pongTimeout = useRef(undefined);\n  const manualReconnect = useCallback(() => {\n    console.log('Manual reconnect triggered');\n    reconnectAttempts.current = 0;\n    connect();\n  }, []);\n  const clearTimers = useCallback(() => {\n    if (reconnectTimeout.current) {\n      window.clearTimeout(reconnectTimeout.current);\n      reconnectTimeout.current = undefined;\n    }\n    if (pingInterval.current) {\n      window.clearInterval(pingInterval.current);\n      pingInterval.current = undefined;\n    }\n    if (pongTimeout.current) {\n      window.clearTimeout(pongTimeout.current);\n      pongTimeout.current = undefined;\n    }\n  }, []);\n  const startHeartbeat = useCallback(() => {\n    clearTimers();\n    const sendPing = () => {\n      var _wsRef$current;\n      if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({\n          type: 'ping'\n        }));\n        pongTimeout.current = window.setTimeout(() => {\n          console.log('Pong not received, closing connection');\n          if (wsRef.current) {\n            wsRef.current.close();\n          }\n        }, PONG_TIMEOUT);\n      }\n    };\n    pingInterval.current = window.setInterval(sendPing, PING_INTERVAL);\n    sendPing(); // Send first ping immediately\n  }, [clearTimers]);\n  const handleMessage = useCallback(event => {\n    var _wsRef$current2;\n    try {\n      const message = JSON.parse(event.data);\n      console.log('Received message:', message.type);\n      switch (message.type) {\n        case 'ping':\n          (_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.send(JSON.stringify({\n            type: 'pong'\n          }));\n          break;\n        case 'pong':\n          if (pongTimeout.current) {\n            clearTimeout(pongTimeout.current);\n            pongTimeout.current = undefined;\n          }\n          break;\n        case 'logs':\n          if (Array.isArray(message.data)) {\n            console.log('Setting initial logs:', message.data.length);\n            setLogs(message.data);\n            setLastUpdate(new Date());\n          }\n          break;\n        case 'log':\n          if (message.data) {\n            console.log('Adding new log');\n            setLogs(prevLogs => [message.data, ...prevLogs]);\n            setLastUpdate(new Date());\n          }\n          break;\n        case 'opportunity':\n          if (message.data) {\n            console.log('New opportunity detected');\n            setOpportunities(prev => [message.data, ...prev]);\n          }\n          break;\n        default:\n          console.log('Unknown message type:', message.type);\n      }\n    } catch (error) {\n      console.error('Error processing message:', error);\n    }\n  }, []);\n  const connect = useCallback(() => {\n    try {\n      var _wsRef$current3;\n      if (((_wsRef$current3 = wsRef.current) === null || _wsRef$current3 === void 0 ? void 0 : _wsRef$current3.readyState) === WebSocket.OPEN) {\n        return;\n      }\n      console.log('Connecting to WebSocket...');\n      const ws = new WebSocket(WS_URL);\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setIsLoading(false);\n        reconnectAttempts.current = 0;\n        wsRef.current = ws;\n        startHeartbeat();\n      };\n      ws.onmessage = handleMessage;\n      ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        wsRef.current = null;\n        clearTimers();\n        if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {\n          console.log(`Attempting to reconnect... (${reconnectAttempts.current + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n          reconnectTimeout.current = window.setTimeout(() => {\n            reconnectAttempts.current++;\n            connect();\n          }, RECONNECT_INTERVAL);\n        } else {\n          setIsLoading(false);\n          console.log('Max reconnection attempts reached');\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n      return () => {\n        clearTimers();\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.close();\n        }\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      return undefined;\n    }\n  }, [handleMessage, startHeartbeat, clearTimers]);\n  useEffect(() => {\n    const cleanup = connect();\n    return () => {\n      if (cleanup) cleanup();\n    };\n  }, [connect]);\n  return {\n    logs,\n    isConnected,\n    isLoading,\n    lastUpdate,\n    opportunities,\n    reconnectAttempts: reconnectAttempts.current,\n    maxReconnectAttempts: MAX_RECONNECT_ATTEMPTS,\n    manualReconnect\n  };\n}\n_s(useWebSocket, \"Q89zY9t5899ZhlpR+CzCy7FVpyU=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","WS_URL","RECONNECT_INTERVAL","MAX_RECONNECT_ATTEMPTS","PING_INTERVAL","PONG_TIMEOUT","useWebSocket","_s","logs","setLogs","isConnected","setIsConnected","isLoading","setIsLoading","lastUpdate","setLastUpdate","Date","opportunities","setOpportunities","wsRef","reconnectAttempts","reconnectTimeout","undefined","pingInterval","pongTimeout","manualReconnect","console","log","current","connect","clearTimers","window","clearTimeout","clearInterval","startHeartbeat","sendPing","_wsRef$current","readyState","WebSocket","OPEN","send","JSON","stringify","type","setTimeout","close","setInterval","handleMessage","event","_wsRef$current2","message","parse","data","Array","isArray","length","prevLogs","prev","error","_wsRef$current3","ws","onopen","onmessage","onclose","onerror","cleanup","maxReconnectAttempts"],"sources":["/Users/oguidomingos/Documents/arbitrage/client/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport { LogEntry, ArbitrageOpportunity } from '../types';\n\nconst WS_URL = 'ws://localhost:3003';\nconst RECONNECT_INTERVAL = 3000;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst PING_INTERVAL = 15000;  // 15 seconds\nconst PONG_TIMEOUT = 5000;   // 5 seconds\n\nexport function useWebSocket() {\n  const [logs, setLogs] = useState<LogEntry[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [lastUpdate, setLastUpdate] = useState<Date>(() => new Date());\n  const [opportunities, setOpportunities] = useState<ArbitrageOpportunity[]>([]);\n\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectAttempts = useRef<number>(0);\n  const reconnectTimeout = useRef<number | undefined>(undefined);\n  const pingInterval = useRef<number | undefined>(undefined);\n  const pongTimeout = useRef<number | undefined>(undefined);\n\n  const manualReconnect = useCallback(() => {\n    console.log('Manual reconnect triggered');\n    reconnectAttempts.current = 0;\n    connect();\n  }, []);\n\n  const clearTimers = useCallback(() => {\n    if (reconnectTimeout.current) {\n      window.clearTimeout(reconnectTimeout.current);\n      reconnectTimeout.current = undefined;\n    }\n    if (pingInterval.current) {\n      window.clearInterval(pingInterval.current);\n      pingInterval.current = undefined;\n    }\n    if (pongTimeout.current) {\n      window.clearTimeout(pongTimeout.current);\n      pongTimeout.current = undefined;\n    }\n  }, []);\n\n  const startHeartbeat = useCallback(() => {\n    clearTimers();\n    \n    const sendPing = () => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({ type: 'ping' }));\n        pongTimeout.current = window.setTimeout(() => {\n          console.log('Pong not received, closing connection');\n          if (wsRef.current) {\n            wsRef.current.close();\n          }\n        }, PONG_TIMEOUT);\n      }\n    };\n\n    pingInterval.current = window.setInterval(sendPing, PING_INTERVAL);\n    sendPing(); // Send first ping immediately\n  }, [clearTimers]);\n\n  const handleMessage = useCallback((event: MessageEvent) => {\n    try {\n      const message = JSON.parse(event.data);\n      console.log('Received message:', message.type);\n\n      switch (message.type) {\n        case 'ping':\n          wsRef.current?.send(JSON.stringify({ type: 'pong' }));\n          break;\n\n        case 'pong':\n          if (pongTimeout.current) {\n            clearTimeout(pongTimeout.current);\n            pongTimeout.current = undefined;\n          }\n          break;\n\n        case 'logs':\n          if (Array.isArray(message.data)) {\n            console.log('Setting initial logs:', message.data.length);\n            setLogs(message.data);\n            setLastUpdate(new Date());\n          }\n          break;\n\n        case 'log':\n          if (message.data) {\n            console.log('Adding new log');\n            setLogs(prevLogs => [message.data, ...prevLogs]);\n            setLastUpdate(new Date());\n          }\n          break;\n\n        case 'opportunity':\n          if (message.data) {\n            console.log('New opportunity detected');\n            setOpportunities(prev => [message.data, ...prev]);\n          }\n          break;\n\n        default:\n          console.log('Unknown message type:', message.type);\n      }\n    } catch (error) {\n      console.error('Error processing message:', error);\n    }\n  }, []);\n\n  const connect = useCallback(() => {\n    try {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        return;\n      }\n\n      console.log('Connecting to WebSocket...');\n      const ws = new WebSocket(WS_URL);\n\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setIsLoading(false);\n        reconnectAttempts.current = 0;\n        wsRef.current = ws;\n        startHeartbeat();\n      };\n\n      ws.onmessage = handleMessage;\n\n      ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        wsRef.current = null;\n        clearTimers();\n\n        if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {\n          console.log(`Attempting to reconnect... (${reconnectAttempts.current + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n          reconnectTimeout.current = window.setTimeout(() => {\n            reconnectAttempts.current++;\n            connect();\n          }, RECONNECT_INTERVAL);\n        } else {\n          setIsLoading(false);\n          console.log('Max reconnection attempts reached');\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n      };\n\n      return () => {\n        clearTimers();\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.close();\n        }\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      return undefined;\n    }\n  }, [handleMessage, startHeartbeat, clearTimers]);\n\n  useEffect(() => {\n    const cleanup = connect();\n    return () => {\n      if (cleanup) cleanup();\n    };\n  }, [connect]);\n\n  return {\n    logs,\n    isConnected,\n    isLoading,\n    lastUpdate,\n    opportunities,\n    reconnectAttempts: reconnectAttempts.current,\n    maxReconnectAttempts: MAX_RECONNECT_ATTEMPTS,\n    manualReconnect\n  };\n}"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAGhE,MAAMC,MAAM,GAAG,qBAAqB;AACpC,MAAMC,kBAAkB,GAAG,IAAI;AAC/B,MAAMC,sBAAsB,GAAG,CAAC;AAChC,MAAMC,aAAa,GAAG,KAAK,CAAC,CAAE;AAC9B,MAAMC,YAAY,GAAG,IAAI,CAAC,CAAG;;AAE7B,OAAO,SAASC,YAAYA,CAAA,EAAG;EAAAC,EAAA;EAC7B,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGZ,QAAQ,CAAa,EAAE,CAAC;EAChD,MAAM,CAACa,WAAW,EAAEC,cAAc,CAAC,GAAGd,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACe,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACiB,UAAU,EAAEC,aAAa,CAAC,GAAGlB,QAAQ,CAAO,MAAM,IAAImB,IAAI,CAAC,CAAC,CAAC;EACpE,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGrB,QAAQ,CAAyB,EAAE,CAAC;EAE9E,MAAMsB,KAAK,GAAGpB,MAAM,CAAmB,IAAI,CAAC;EAC5C,MAAMqB,iBAAiB,GAAGrB,MAAM,CAAS,CAAC,CAAC;EAC3C,MAAMsB,gBAAgB,GAAGtB,MAAM,CAAqBuB,SAAS,CAAC;EAC9D,MAAMC,YAAY,GAAGxB,MAAM,CAAqBuB,SAAS,CAAC;EAC1D,MAAME,WAAW,GAAGzB,MAAM,CAAqBuB,SAAS,CAAC;EAEzD,MAAMG,eAAe,GAAGzB,WAAW,CAAC,MAAM;IACxC0B,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;IACzCP,iBAAiB,CAACQ,OAAO,GAAG,CAAC;IAC7BC,OAAO,CAAC,CAAC;EACX,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMC,WAAW,GAAG9B,WAAW,CAAC,MAAM;IACpC,IAAIqB,gBAAgB,CAACO,OAAO,EAAE;MAC5BG,MAAM,CAACC,YAAY,CAACX,gBAAgB,CAACO,OAAO,CAAC;MAC7CP,gBAAgB,CAACO,OAAO,GAAGN,SAAS;IACtC;IACA,IAAIC,YAAY,CAACK,OAAO,EAAE;MACxBG,MAAM,CAACE,aAAa,CAACV,YAAY,CAACK,OAAO,CAAC;MAC1CL,YAAY,CAACK,OAAO,GAAGN,SAAS;IAClC;IACA,IAAIE,WAAW,CAACI,OAAO,EAAE;MACvBG,MAAM,CAACC,YAAY,CAACR,WAAW,CAACI,OAAO,CAAC;MACxCJ,WAAW,CAACI,OAAO,GAAGN,SAAS;IACjC;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMY,cAAc,GAAGlC,WAAW,CAAC,MAAM;IACvC8B,WAAW,CAAC,CAAC;IAEb,MAAMK,QAAQ,GAAGA,CAAA,KAAM;MAAA,IAAAC,cAAA;MACrB,IAAI,EAAAA,cAAA,GAAAjB,KAAK,CAACS,OAAO,cAAAQ,cAAA,uBAAbA,cAAA,CAAeC,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;QAChDpB,KAAK,CAACS,OAAO,CAACY,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC;UAAEC,IAAI,EAAE;QAAO,CAAC,CAAC,CAAC;QACpDnB,WAAW,CAACI,OAAO,GAAGG,MAAM,CAACa,UAAU,CAAC,MAAM;UAC5ClB,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;UACpD,IAAIR,KAAK,CAACS,OAAO,EAAE;YACjBT,KAAK,CAACS,OAAO,CAACiB,KAAK,CAAC,CAAC;UACvB;QACF,CAAC,EAAExC,YAAY,CAAC;MAClB;IACF,CAAC;IAEDkB,YAAY,CAACK,OAAO,GAAGG,MAAM,CAACe,WAAW,CAACX,QAAQ,EAAE/B,aAAa,CAAC;IAClE+B,QAAQ,CAAC,CAAC,CAAC,CAAC;EACd,CAAC,EAAE,CAACL,WAAW,CAAC,CAAC;EAEjB,MAAMiB,aAAa,GAAG/C,WAAW,CAAEgD,KAAmB,IAAK;IAAA,IAAAC,eAAA;IACzD,IAAI;MACF,MAAMC,OAAO,GAAGT,IAAI,CAACU,KAAK,CAACH,KAAK,CAACI,IAAI,CAAC;MACtC1B,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAEuB,OAAO,CAACP,IAAI,CAAC;MAE9C,QAAQO,OAAO,CAACP,IAAI;QAClB,KAAK,MAAM;UACT,CAAAM,eAAA,GAAA9B,KAAK,CAACS,OAAO,cAAAqB,eAAA,uBAAbA,eAAA,CAAeT,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC;YAAEC,IAAI,EAAE;UAAO,CAAC,CAAC,CAAC;UACrD;QAEF,KAAK,MAAM;UACT,IAAInB,WAAW,CAACI,OAAO,EAAE;YACvBI,YAAY,CAACR,WAAW,CAACI,OAAO,CAAC;YACjCJ,WAAW,CAACI,OAAO,GAAGN,SAAS;UACjC;UACA;QAEF,KAAK,MAAM;UACT,IAAI+B,KAAK,CAACC,OAAO,CAACJ,OAAO,CAACE,IAAI,CAAC,EAAE;YAC/B1B,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEuB,OAAO,CAACE,IAAI,CAACG,MAAM,CAAC;YACzD9C,OAAO,CAACyC,OAAO,CAACE,IAAI,CAAC;YACrBrC,aAAa,CAAC,IAAIC,IAAI,CAAC,CAAC,CAAC;UAC3B;UACA;QAEF,KAAK,KAAK;UACR,IAAIkC,OAAO,CAACE,IAAI,EAAE;YAChB1B,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;YAC7BlB,OAAO,CAAC+C,QAAQ,IAAI,CAACN,OAAO,CAACE,IAAI,EAAE,GAAGI,QAAQ,CAAC,CAAC;YAChDzC,aAAa,CAAC,IAAIC,IAAI,CAAC,CAAC,CAAC;UAC3B;UACA;QAEF,KAAK,aAAa;UAChB,IAAIkC,OAAO,CAACE,IAAI,EAAE;YAChB1B,OAAO,CAACC,GAAG,CAAC,0BAA0B,CAAC;YACvCT,gBAAgB,CAACuC,IAAI,IAAI,CAACP,OAAO,CAACE,IAAI,EAAE,GAAGK,IAAI,CAAC,CAAC;UACnD;UACA;QAEF;UACE/B,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEuB,OAAO,CAACP,IAAI,CAAC;MACtD;IACF,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdhC,OAAO,CAACgC,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACnD;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM7B,OAAO,GAAG7B,WAAW,CAAC,MAAM;IAChC,IAAI;MAAA,IAAA2D,eAAA;MACF,IAAI,EAAAA,eAAA,GAAAxC,KAAK,CAACS,OAAO,cAAA+B,eAAA,uBAAbA,eAAA,CAAetB,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;QAChD;MACF;MAEAb,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;MACzC,MAAMiC,EAAE,GAAG,IAAItB,SAAS,CAACrC,MAAM,CAAC;MAEhC2D,EAAE,CAACC,MAAM,GAAG,MAAM;QAChBnC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;QAClChB,cAAc,CAAC,IAAI,CAAC;QACpBE,YAAY,CAAC,KAAK,CAAC;QACnBO,iBAAiB,CAACQ,OAAO,GAAG,CAAC;QAC7BT,KAAK,CAACS,OAAO,GAAGgC,EAAE;QAClB1B,cAAc,CAAC,CAAC;MAClB,CAAC;MAED0B,EAAE,CAACE,SAAS,GAAGf,aAAa;MAE5Ba,EAAE,CAACG,OAAO,GAAG,MAAM;QACjBrC,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC;QACrChB,cAAc,CAAC,KAAK,CAAC;QACrBQ,KAAK,CAACS,OAAO,GAAG,IAAI;QACpBE,WAAW,CAAC,CAAC;QAEb,IAAIV,iBAAiB,CAACQ,OAAO,GAAGzB,sBAAsB,EAAE;UACtDuB,OAAO,CAACC,GAAG,CAAC,+BAA+BP,iBAAiB,CAACQ,OAAO,GAAG,CAAC,IAAIzB,sBAAsB,GAAG,CAAC;UACtGkB,gBAAgB,CAACO,OAAO,GAAGG,MAAM,CAACa,UAAU,CAAC,MAAM;YACjDxB,iBAAiB,CAACQ,OAAO,EAAE;YAC3BC,OAAO,CAAC,CAAC;UACX,CAAC,EAAE3B,kBAAkB,CAAC;QACxB,CAAC,MAAM;UACLW,YAAY,CAAC,KAAK,CAAC;UACnBa,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;QAClD;MACF,CAAC;MAEDiC,EAAE,CAACI,OAAO,GAAIN,KAAK,IAAK;QACtBhC,OAAO,CAACgC,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;MAC1C,CAAC;MAED,OAAO,MAAM;QACX5B,WAAW,CAAC,CAAC;QACb,IAAI8B,EAAE,CAACvB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;UACpCqB,EAAE,CAACf,KAAK,CAAC,CAAC;QACZ;MACF,CAAC;IACH,CAAC,CAAC,OAAOa,KAAK,EAAE;MACdhC,OAAO,CAACgC,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;MAC5D,OAAOpC,SAAS;IAClB;EACF,CAAC,EAAE,CAACyB,aAAa,EAAEb,cAAc,EAAEJ,WAAW,CAAC,CAAC;EAEhDhC,SAAS,CAAC,MAAM;IACd,MAAMmE,OAAO,GAAGpC,OAAO,CAAC,CAAC;IACzB,OAAO,MAAM;MACX,IAAIoC,OAAO,EAAEA,OAAO,CAAC,CAAC;IACxB,CAAC;EACH,CAAC,EAAE,CAACpC,OAAO,CAAC,CAAC;EAEb,OAAO;IACLrB,IAAI;IACJE,WAAW;IACXE,SAAS;IACTE,UAAU;IACVG,aAAa;IACbG,iBAAiB,EAAEA,iBAAiB,CAACQ,OAAO;IAC5CsC,oBAAoB,EAAE/D,sBAAsB;IAC5CsB;EACF,CAAC;AACH;AAAClB,EAAA,CA5KeD,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}